#!/usr/bin/env php
<?php
/* Copyright 2021 Romain "Artefact2" Dal Maso <romain.dalmaso@artefact2.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *	   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* https://www.kernel.org/doc/Documentation/iostats.txt */
const READ_SECTORS = 5;
const WRITTEN_SECTORS = 9;
const IOS_IN_PROGRESS = 11;
const WEIGHTED_MS_IOS = 13;

/* https://www.kernel.org/doc/html/latest/filesystems/proc.html */
const RX_BYTES = 1;
const TX_BYTES = 9;
const CPU_USER = 1;
const CPU_NICE = 2;
const CPU_SYSTEM = 3;
const CPU_IDLE = 4;
const CPU_IOWAIT = 5;
const PROC_PID = 0;
const PROC_TCOMM = 1;
const PROC_STATE = 2;
const PROC_PPID = 3;
const PROC_UTIME = 13;
const PROC_STIME = 14;
const PROC_START_TIME = 21;
const PROC_BLKIO_TICKS = 41;

const MEMORY_REFRESH_INTERVAL_SEC = 0.1;
const PRESSURE_REFRESH_INTERVAL_SEC = 1.0;
const CPU_REFRESH_INTERVAL_SEC = 0.1;
const DISK_AND_NETWORK_REFRESH_INTERVAL_SEC = 1.0;
const DMCACHE_REFRESH_INTERVAL_SEC = 120.0; /* annoying audit spam in journal */
const PROC_REFRESH_INTERVAL_SEC = 2.0;

const BLOCK_DEVICE_BLACKLIST = '/^(dm-|loop[0-9])/';
const NETWORK_DEVICE_BLACKLIST = '/^(br|tap)[0-9]/';
const PROCESS_LINES = 9;

const EOL = "\e[0K\n";
const CSI_HEADINGS = "\e[1m";
const CSI_RESET = "\e[0m";
const CSI_MED = "\e[1;93m";
const CSI_HIGH = "\e[1;91m";
const CSI_CRIT = "\e[1;95m";



function read_diskstats(): array {
	$stats = [ microtime(true), [] ];

	foreach(explode("\n", file_get_contents('/proc/diskstats')) as $dev) {
		if($dev === '') continue;
		$fields = preg_split("/\\s+/", ltrim($dev));
		if(preg_match(BLOCK_DEVICE_BLACKLIST, $fields[2])) continue;
		if(isset($stats[1][substr($fields[2], 0, -1)])) continue; /* skip partitions */
		$stats[1][$fields[2]] = $fields;
	}

	return $stats;
}

function read_netstats(): array {
	$data = [ microtime(true), [] ];

	$k = explode("\n", file_get_contents('/proc/net/dev'));
	array_shift($k);
	array_shift($k);
	array_pop($k);
	foreach($k as $line) {
		$fields = preg_split("/\\s+/", ltrim($line));
		$ifname = substr($fields[0], 0, -1);
		if(preg_match(NETWORK_DEVICE_BLACKLIST, $ifname)) continue;
		$data[1][$ifname] = $fields;
	}

	return $data;
}

function format_bytes(float $b): string {
	if(abs($b) >= 10000 * 1024 * 1024) {
		return sprintf("%7.2fG", $b / 1024. / 1024. / 1024.);
	}
	if(abs($b) >= 10000 * 1024) {
		return sprintf("%7.2fM", $b / 1024. / 1024.);
	}
	return sprintf("%7.2fK", $b / 1024.);
}

function format_disk_and_netstats(array $dold, array $dnew, array $nold, array $nnew): string {
	$r = sprintf(
		"%s%8s %8s %8s %8s %8s %8s %8s %8s%s%s",
		CSI_HEADINGS, "DEVICE", "READ/s", "WRITE/s", "PRESSURE", "", "IFACE", "RX/s", "TX/s", CSI_RESET, EOL
	);
	$tdiff = $dnew[0] - $dold[0];
	while($dnew[1] !== [] || $nnew[1] !== []) {
		if($dnew[1] !== []) {
			$e = $dold[1][$kname = key($dnew[1])]; /* XXX could be unset */
			$f = $dnew[1][$kname];
			unset($dnew[1][$kname]);

			/* XXX: blk size is always 512? */
			$pressure = ($f[WEIGHTED_MS_IOS] - $e[WEIGHTED_MS_IOS]) / 1000.0 / $tdiff;
			$r .= sprintf(
				"%8s %8s %8s %s%8.2f%s",
				$kname,
				format_bytes(512 * ($f[READ_SECTORS] - $e[READ_SECTORS]) / $tdiff),
				format_bytes(512 * ($f[WRITTEN_SECTORS] - $e[WRITTEN_SECTORS]) / $tdiff),
				$pressure >= 0.9 ? CSI_CRIT : '',
				$pressure, CSI_RESET
			);
		} else {
			$r .= sprintf("%8s %8s %8s %8s", "", "", "", "");
		}

		$r .= sprintf(" %8s ", "");

		if($nnew[1] !== []) {
			$e = $nold[1][$k = key($nnew[1])]; /* XXX could be undefined */
			$f = $nnew[1][$k];
			unset($nnew[1][$k]);

			$r .= sprintf(
				"%8s %8s %8s%s",
				$k,
				format_bytes(($f[RX_BYTES] - $e[RX_BYTES]) / $tdiff),
				format_bytes(($f[TX_BYTES] - $e[TX_BYTES]) / $tdiff),
				EOL
			);
		} else {
			$r .= sprintf("%8s %8s %8s%s", "", "", "", EOL);
		}
	}
	return $r;
}

function read_vmstats(): array {
	$stats = [ microtime(true), []];
	foreach(explode("\n", file_get_contents('/proc/vmstat')) as $line) {
		if($line === '') continue;
		list($k, $v) = explode(" ", $line);
		$stats[1][$k] = $v;
	}

	$zrams = [];
	for($i = 0;; ++$i) {
		if(!file_exists($f = '/sys/block/zram'.$i.'/mm_stat')) break;
		$zrams['zram'.$i] = preg_split('/\\s+/', trim(file_get_contents($f)));
	}
	$stats[] = $zrams;

	$swaps = explode("\n", file_get_contents("/proc/swaps"));
	$fswaps = [];
	array_shift($swaps);
	array_pop($swaps);
	foreach($swaps as $sline) {
		$fields = preg_split('/\\s+/', $sline);
		$fswaps[$fields[0]] = $fields;
	}
	$stats[] = $fswaps;

	return $stats;
}

function format_vmstats(array $vms): string {
	return sprintf(
		"%s%8s %8s %8s %8s %8s %8s %8s %8s%s%s%8s %8s %8s %8s %s%8s%s %s%8s%s %8s %8s%s",
		CSI_HEADINGS, "ACTIVE", "INACTIVE", "CACHED", "FREE", "DIRTY", "W_BACK", "SWAP",
		$vms[2] !== [] ? "ZRAM" : '',
		CSI_RESET, EOL,
		format_bytes(4096 * ($vms[1]['nr_active_anon'] + $vms[1]['nr_active_file'])),
		format_bytes(4096 * ($vms[1]['nr_inactive_anon'] + $vms[1]['nr_inactive_file'])),
		format_bytes(4096 * ($vms[1]['nr_active_file'] + $vms[1]['nr_inactive_file'] + $vms[1]['nr_slab_unreclaimable'] + $vms[1]['nr_slab_reclaimable'] + $vms[1]['nr_kernel_misc_reclaimable'] + $vms[1]['nr_swapcached'])),
		format_bytes(4096 * $vms[1]['nr_free_pages']),
		$vms[1]['nr_dirty'] >= $vms[1]['nr_dirty_threshold'] ? CSI_CRIT : ($vms[1]['nr_dirty'] >= $vms[1]['nr_dirty_background_threshold'] ? CSI_HIGH : ''),
		format_bytes(4096 * $vms[1]['nr_dirty']), CSI_RESET,
		$vms[1]['nr_writeback'] > 0 ? CSI_CRIT : '', format_bytes(4096 * $vms[1]['nr_writeback']), CSI_RESET,
		format_bytes(array_sum(array_column($vms[3], 3)) * 1024 - 4096 * $vms[1]['nr_swapcached']),
		$vms[2] !== [] ? format_bytes(array_sum(array_column($vms[2], 2))) : '',
		EOL
	);
}

function read_cpustats(): array {
	$stats = [ microtime(true), [] ];
	$k = explode("\n", file_get_contents('/proc/stat'));
	array_pop($k);
	foreach($k as $line) {
		$fields = preg_split("/\\s+/", ltrim($line));
		$stats[1][$fields[0]] = $fields;
	}
	return $stats;
}

function cpu_percentage_colour($perc): string {
	if($perc >= 80.0) return CSI_CRIT;
	if($perc >= 60.0) return CSI_HIGH;
	if($perc >= 40.0) return CSI_MED;
	return '';
}

function format_cpustats(array $cold, array $cnew): string {
	$tdiff = $cnew[0] - $cold[0];
	$i = 0; $table = []; $totals = [];
	while(isset($cnew[1]['cpu'.$i])) {
		$v = $cnew[1]['cpu'.$i];
		$u = $cold[1]['cpu'.$i]; /* XXX potentially undefined */

		$table['IOWAIT'][] = ($v[CPU_IOWAIT] - $u[CPU_IOWAIT]);
		$table['SYSTEM'][] = ($v[CPU_SYSTEM] - $u[CPU_SYSTEM]);
		$table['USER'][] = ($v[CPU_USER] - $u[CPU_USER]);
		$table['NICE'][] = ($v[CPU_NICE] - $u[CPU_NICE]);

		$v[CPU_IDLE] = $u[CPU_IDLE] = 0;
		array_shift($v);
		array_shift($u);
		$totals[] = array_sum($v) - array_sum($u);

		++$i;
	}
	$order = array_keys($table['USER']);
	usort($order, function($u, $v) use($table, $totals) {
		$s = $totals[$v] - $totals[$u];
		if($s !== 0) return $s;
		$v = array_column($table, $v);
		$u = array_column($table, $u);
		return max($v) - max($u);
	});
	$r = '';
	foreach($table as $hdr => $fields) {
		$r .= sprintf("%s%8s%s ", CSI_HEADINGS, $hdr, CSI_RESET);
		foreach($order as $k) {
			$f = $fields[$k] / $tdiff;
			$t = $totals[$k] / $tdiff;

			if($f >= 95.0) {
				$char = 'X';
			} else if($f >= 50.0) {
				$char = '|';
			} else if($f >= 20.0) {
				$char = '|';
			} else if($f >= 1.0) {
				$char = '.';
			} else {
				$char = ' ';
			}

			$r .= cpu_percentage_colour($t).$char.CSI_RESET;
		}
		$r .= EOL;
	}
	return $r;
}

function read_pressurestats(): array {
	$stats = [ microtime(true), [] ];
	foreach([ 'cpu', 'memory', 'io' ] as $type) {
		$s = explode("\n", file_get_contents('/proc/pressure/'.$type));
		array_pop($s);
		foreach($s as $line) {
			$fields = explode(' ', $line);
			$subtype = array_shift($fields);
			foreach($fields as $f) {
				list($k, $v) = explode('=', $f, 2);
				$stats[1][$type][$subtype][$k] = $v;
			}
		}
	}
	return $stats;
}

function format_pressure(float $p): string {
	if($p >= 10.0) {
		return sprintf("%s%7.2f%%%s", CSI_CRIT, $p, CSI_RESET);
	}
	if($p >= 5.0) {
		return sprintf("%s%7.2f%%%s", CSI_HIGH, $p, CSI_RESET);
	}
	if($p >= 1.0) {
		return sprintf("%s%7.2f%%%s", CSI_MED, $p, CSI_RESET);
	}
	return sprintf("%7.2f%%", $p);
}

function format_pressurestats(array $pstats): string {
	$r = sprintf(
		"%s%8s %8s %8s %8s %8s %8s %8s%s%s",
		CSI_HEADINGS, "PSI", "SOME_CPU", "FULL_CPU", "SOME_MEM", "FULL_MEM", "SOME_IO", "FULL_IO", CSI_RESET, EOL
	);
	foreach([ 'avg10', 'avg60', 'avg300' ] as $k) {
		$r .= sprintf(
			"%8s %s %s %s %s %s %s%s",
			$k,
			format_pressure($pstats[1]['cpu']['some'][$k]),
			format_pressure($pstats[1]['cpu']['full'][$k]),
			format_pressure($pstats[1]['memory']['some'][$k]),
			format_pressure($pstats[1]['memory']['full'][$k]),
			format_pressure($pstats[1]['io']['some'][$k]),
			format_pressure($pstats[1]['io']['full'][$k]),
			EOL
		);
	}
	return $r;
}

function read_dmstatus(): array {
	$status = [ microtime(true), [] ];
	for($i = 0;; ++$i) {
		if(!file_exists($f = '/dev/dm-'.$i)) return $status;
		exec('sudo -n dmsetup status '.escapeshellarg($f).' 2>/dev/null', $table, $res);
		if($res !== 0) return $status;
		foreach($table as &$t) {
			$t = explode(' ', $t);
		}
		$status[1]['dm-'.$i] = $table;
		unset($t);
		unset($table);
	}
}

function format_dmcachestats(array $dmstatus): string {
	$r = sprintf(
		"%s%8s %8s %8s %8s %8s %8s %8s %8s%s%s",
		CSI_HEADINGS, "DM-CACHE", "CACHED", "CACHED_%", "R_HIT%", "W_HIT%", "PROMOTED", "DEMOTED", "DIRTY", CSI_RESET, EOL
	);
	$hascaches = false;

	foreach($dmstatus[1] as $kname => $tentries) {
		foreach($tentries as $fields) {
			if($fields[2] !== 'cache') continue;
			$hascaches = true;

			/* https://www.kernel.org/doc/html/latest/admin-guide/device-mapper/cache.html#status */
			$cu = explode('/', $fields[6], 2);
			$r .= sprintf(
				"%8s %8s %7.2f%% %7.2f%% %7.2f%% %8s %8s %s%8s%s%s",
				$kname,
				format_bytes($cu[0] * $fields[5] * 512),
				100.0 * $cu[0] / $cu[1],
				100.0 * $fields[7] / ($fields[7] + $fields[8]),
				100.0 * $fields[9] / ($fields[9] + $fields[10]),
				format_bytes($fields[12] * $fields[5] * 512),
				format_bytes($fields[11] * $fields[5] * 512),
				$fields[13] > 0 ? CSI_CRIT : '', format_bytes($fields[13] * $fields[5] * 512), CSI_RESET,
				EOL
			);
		}
	}
	return $hascaches ? $r : '';
}

function read_procstats(): array {
	$stats = [ microtime(true), [], explode(' ', file_get_contents('/proc/uptime')) ];
	/* XXX: could be slow */
	foreach(glob('/proc/[123456789]*/task/[123456789]*/stat', GLOB_NOSORT) as $s) {
		$s = @file_get_contents($s);
		if(!$s) continue; /* Process died, move on */
		$fields = explode(' ', $s);
		if(count($fields) < 52) continue;
		if(count($fields) !== 52) {
			array_splice($fields, 1, count($fields) - 51, implode(' ', array_slice($fields, 1, count($fields) - 51)));
		}
		$stats[1][$fields[0]] = $fields;
	}
	return $stats;
}

function format_cmdline(array $g, array $p) {
	/* May fail on occasion as processes die */
	$cmdline = @file_get_contents('/proc/'.$p[PROC_PID].'/cmdline');
	if(!$cmdline) {
		$cmdline = @file_get_contents('/proc/'.$p[PROC_PPID].'/task/'.$p[PROC_PID].'/cmdline');
	}
	if(!$cmdline) {
		if($g[PROC_TCOMM] === $p[PROC_TCOMM]) {
			return $p[PROC_TCOMM];
		}
		return substr($g[PROC_TCOMM], 0, -1).' '.substr($p[PROC_TCOMM], 1);
	}
	$args = preg_split('/\\0/', $cmdline);
	foreach($args as &$a) {
		if(strpos($a, ' ') !== false) {
			$a = str_replace([ '\\', '"' ], [ '\\\\', '\\"' ], $a);
			$a = '"'.$a.'"';
		}
	}
	if($args[0][0] === '/') {
		$path = explode('/', $args[0]);
		$args[0] = array_pop($path);
	}
	$args[0] = CSI_HEADINGS.($bin = $args[0]).CSI_RESET;
	if($bin !== substr($p[PROC_TCOMM], 1, -1)) {
		$args[0] = $p[PROC_TCOMM].' '.$args[0];
	}
	return implode(' ', $args);
}

function format_procstats(array $pold, array $pnew): string {
	$r = sprintf(
		"%s%8s %1s %4s %4s %-8s%s%s",
		CSI_HEADINGS, "PID", "S", "IOW%", "CPU%", "CMDLINE", CSI_RESET, EOL
	);
	$tdiff = $pnew[0] - $pold[0];
	$iopc = $cpupc = [];
	foreach($pnew[1] as $pid => $f) {
		if(isset($pold[1][$pid])) {
			$of = $pold[1][$pid];
			$iopc[$pid] = ($f[PROC_BLKIO_TICKS] - $of[PROC_BLKIO_TICKS]) / $tdiff;
			$cpupc[$pid] = ($f[PROC_UTIME] + $f[PROC_STIME] - $of[PROC_UTIME] - $of[PROC_STIME]) / $tdiff;
		} else {
			$ptdiff = max(0.01, $pnew[2][0] - $f[PROC_START_TIME] / 100.0);
			$iopc[$pid] = $f[PROC_BLKIO_TICKS] / $ptdiff;
			$cpupc[$pid] = ($f[PROC_UTIME] + $f[PROC_STIME]) / $ptdiff;
		}
	}
	uksort($pnew[1], function($a, $b) use($iopc, $cpupc) { return $iopc[$b] + $cpupc[$b] - $iopc[$a] - $cpupc[$a]; });
	foreach(array_slice($pnew[1], 0, PROCESS_LINES) as $fields) {
		if($cpupc[$fields[PROC_PID]] === 0.0 && $iopc[$fields[PROC_PID]] === 0.0) break;
		$r .= sprintf(
			"%8.0f %s%1s%s %s%3.0f%%%s %s%3.0f%%%s %-58s%s",
			$fields[PROC_PID],
			$fields[PROC_STATE] === 'D' ? CSI_CRIT : ($fields[PROC_STATE] === 'R' ? CSI_MED : ''), $fields[PROC_STATE], CSI_RESET,
			cpu_percentage_colour($iopc[$fields[PROC_PID]]), $iopc[$fields[PROC_PID]], CSI_RESET,
			cpu_percentage_colour($cpupc[$fields[PROC_PID]]), $cpupc[$fields[PROC_PID]], CSI_RESET,
			substr(format_cmdline($pnew[1][$fields[PROC_PPID]] ?: $fields, $fields), 0, 58), /* XXX */
			EOL
		);
	}
	return $r;
}




$ncstats = read_cpustats();
$ndstats = read_diskstats();
$nnstats = read_netstats();
$nprocstats = read_procstats();
$vmstats = [ 0 ];
$pstats = [ 0 ];
$dmcstats = [ 0 ];

$M = max(DISK_AND_NETWORK_REFRESH_INTERVAL_SEC, CPU_REFRESH_INTERVAL_SEC, PROC_REFRESH_INTERVAL_SEC);
$m = min(DISK_AND_NETWORK_REFRESH_INTERVAL_SEC, CPU_REFRESH_INTERVAL_SEC, PROC_REFRESH_INTERVAL_SEC);
printf("Waiting for %.2f seconds to collect statistics...\n", $M);
usleep($M * 1000000.0);

echo "\e[1;1H\e[0J";
while(true) {
	$t = microtime(true);
	if($t - $vmstats[0] >= MEMORY_REFRESH_INTERVAL_SEC) {
		$vmstats = read_vmstats();
		$fvmstats = format_vmstats($vmstats);
	}
	if($t - $pstats[0] >= PRESSURE_REFRESH_INTERVAL_SEC) {
		$pstats = read_pressurestats();
		$fpstats = format_pressurestats($pstats);
	}
	if($t - $nnstats[0] >= DISK_AND_NETWORK_REFRESH_INTERVAL_SEC) {
		$dstats = $ndstats;
		$ndstats = read_diskstats();

		$nstats = $nnstats;
		$nnstats = read_netstats();

		$fdstats = format_disk_and_netstats($dstats, $ndstats, $nstats, $nnstats);
	}
	if($t - $ncstats[0] >= CPU_REFRESH_INTERVAL_SEC) {
		$cstats = $ncstats;
		$ncstats = read_cpustats();
		$fcstats = format_cpustats($cstats, $ncstats);
	}
	if($t - $dmcstats[0] >= DMCACHE_REFRESH_INTERVAL_SEC) {
		$dmcstats = read_dmstatus();
		$fdmcstats = format_dmcachestats($dmcstats);
	}
	if($t - $nprocstats[0] >= PROC_REFRESH_INTERVAL_SEC) {
		$procstats = $nprocstats;
		$nprocstats = read_procstats();
		$fprocstats = format_procstats($procstats, $nprocstats);
	}

	echo "\e[1;1H",
		$fvmstats, EOL,
		$fpstats, EOL,
		$fcstats, EOL,
		$fdstats, EOL,
		$fdmcstats, $fdmcstats !== '' ? EOL : '',
		$fprocstats, "\e[0J";
	usleep($m * 1000000.0);
}
